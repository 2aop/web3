# 比特币的数据结构

## 1. Hash pointer（哈希指针）

区块链结构本身为一条链表，节点为区块。而传统链表实现，便是通过指针将各个节点串联起来而称为最终的

链。如下便是我们最常见的一个链表：

![image-20240611213713633](C:\Users\26440\AppData\Roaming\Typora\typora-user-images\image-20240611213713633.png)

但在区块链系统中，并未采用指针，而是使用了**哈希指针**

传统指针存储的值一般是地址，而哈希指针存储的是上一个区块的哈希值

比如**区块2**的**哈希指针**存储的值是**区块1**的哈希值，而这个哈希值是由区块1的区块头的所有内容结果哈希函数得来的

所以一旦区块1 的区块头里面的值改变了 ==》 区块1区块1 的区块头里面的值经过哈希函数得到的值也就改变了 ===》 那么区块2的哈希指针存储的值也就对不上了，所以 很容易就会发现区块1被篡改了。这个就是不可篡改性（我的理解是不可篡改 不是指不能篡改，而且篡改之后很容易被发现）



如图中所示，如果我们想要破坏区块链完整性。篡改B的内容，而C中保存有B的哈希值，所以C也得进行修

改。而同样C后区块也得修改。而用户只需要记住最后一个区块链的哈希地址，就可以检测区块链上内容是否

被篡改。 在实际应用中，一整条链可能会被切断分开保存在多个地方。若用户仅仅具有其中一段，当用到前面

部分区块数据时，直接问系统中其他节点要即可，当要到之后，仅仅通过计算要到的最后一个哈希值和自己保

存哈希值是否一致可以判断所给内容是否确实为区块链上真实的内容

![image-20240611214401964](C:\Users\26440\AppData\Roaming\Typora\typora-user-images\image-20240611214401964.png)



## 2. Merkle Tree(默克尔树**)**

Merkle Tree是比特币系统中又一个重要的数据结构 首先，回顾一下Binary Tree(如果不懂请自行复习数据结

构)。Merkle Tree和Binary Tree的区别有哪些？

### 2.1. Merkle Tree用哈希指针代替了普通指针

![image-20240611214538376](C:\Users\26440\AppData\Roaming\Typora\typora-user-images\image-20240611214538376.png)

其中A、B、C、D为数据块。可见，A和B各有一个哈希值，将其合并放在一个节点中，C和D同样操作，

而后，针对得到的两个节点分别取哈希，又可以得到两个新的哈希值，即为图中根节点。实际中，在区块块头

中存储的是根节点的哈希值（对其再取一次哈希）。



该数据结构的优点在于：只需要记住Root Hash（根哈希值），便可以检测出对树中任何部位的修改。 例如，

所绘制Merkle Tree中节点B发生了改变，则对应的第二层第一个节点中第二个哈希值便也会发生改变，进而根

节点中第一个哈希值也会发生改变，从而导致根哈希值也发生了改变。



在比特币系统中，不同区块通过哈希值指针连接，在同一个区块中的多个交易（数据块），则通过Merkle Tree

的形式组织在一起。区块本身分为两部分（块头和块身），在块头中存在有根哈希值（没有交易的具体信

息），块身中存在交易列表。



### 2.2. Merkle Tree的实际用途 

途 Merkle Tree可以用于提供Merkle Proof。关于Merkle proof，需要先了解比特币系统

中节点。比特币中节点分为**轻节点**和**全节点**。全节点保存整个区块的所有内容，而轻节点仅仅保存区块的块头

信息。



为什么要分轻节点和全节点？ 因为硬件的局限。一个区块大小为1MB，对于移动便携设备来说，如果存储区块

的所有内容，则所需空间过大，而这是不现实的。所以轻节点只需要存储区块块头信息，全节点存储区块所有

内容即可。

(全节点 一般是运行在服务端，需要下载比特币的客户端，而轻节点一般是钱包APP 运行在移动设备上)



当需要向轻节点证明某条交易是否被写入区块链，便需要用到Merkle proof。我们将交易到根节点这一条路径称为

Merkle proof，全节点将整个Merkle proof发送给轻节点（如下图所示），轻节点即可根据其算出根哈希值，和自己

保存的对比，从而验证该交易是否被写入区块链。只要沿着该路径，所有哈希值都正确，说明内容没有被修改过。

![image-20240611214930155](C:\Users\26440\AppData\Roaming\Typora\typora-user-images\image-20240611214930155.png)

**思考**：是否存在不安全的情况？如下图我们要验证B，但是H(1)和H(4)都是全节点提供的。全节点可否修改B，

通过H(1)调整，使得修改过后的H(1)和轻节点计算出的H(2)一起取得哈希仍然为H(3)？

![image-20240611215100659](C:\Users\26440\AppData\Roaming\Typora\typora-user-images\image-20240611215100659.png)

**答**：

轻节点是有根哈希值的，假如交易B是一个假的交易，那么全节点就要改变H(1)的值，使H(1)跟这个假H(2) 得到的哈希值等于H(3)

根据之前的 collision resistance 性质 这是不可能的。



